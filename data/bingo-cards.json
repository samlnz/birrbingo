// js/bingo-cards.js - Fixed 500 Bingo Cards
class BingoCards {
    constructor() {
        // Fixed card patterns for cards 1-500
        this.cardPatterns = this.generateFixedCards();
    }
    
    generateFixedCards() {
        // This generates 500 unique but consistent bingo cards
        // Each card has the same numbers for the same card ID
        const patterns = {};
        
        for (let cardId = 1; cardId <= 500; cardId++) {
            patterns[cardId] = this.generateCard(cardId);
        }
        
        return patterns;
    }
    
    generateCard(seed) {
        // Use seed to generate consistent numbers
        const card = {
            id: seed,
            numbers: [],
            rows: []
        };
        
        // BINGO column ranges
        const ranges = [
            {letter: 'B', min: 1, max: 15},
            {letter: 'I', min: 16, max: 30},
            {letter: 'N', min: 31, max: 45},
            {letter: 'G', min: 46, max: 60},
            {letter: 'O', min: 61, max: 75}
        ];
        
        // Generate numbers for each column
        for (let col = 0; col < 5; col++) {
            const columnNumbers = [];
            const range = ranges[col];
            
            // Generate 5 unique numbers for this column
            for (let i = 0; i < 5; i++) {
                // Use deterministic algorithm based on seed and position
                const hash = this.hashCode(`${seed}-${col}-${i}`);
                const number = (hash % (range.max - range.min + 1)) + range.min;
                
                // Ensure uniqueness in column
                let uniqueNum = number;
                let attempts = 0;
                while (columnNumbers.includes(uniqueNum) && attempts < 100) {
                    uniqueNum = ((uniqueNum + 1 - range.min) % (range.max - range.min + 1)) + range.min;
                    attempts++;
                }
                columnNumbers.push(uniqueNum);
            }
            
            // Sort numbers in column
            columnNumbers.sort((a, b) => a - b);
            
            // Add to card structure
            for (let row = 0; row < 5; row++) {
                if (!card.numbers[row]) card.numbers[row] = [];
                card.numbers[row][col] = columnNumbers[row];
            }
        }
        
        // Mark center as FREE
        card.numbers[2][2] = 'FREE';
        
        // Convert to flat array for easy access
        card.flatNumbers = [];
        for (let row = 0; row < 5; row++) {
            for (let col = 0; col < 5; col++) {
                card.flatNumbers.push(card.numbers[row][col]);
            }
        }
        
        return card;
    }
    
    hashCode(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash);
    }
    
    getCard(cardId) {
        return this.cardPatterns[cardId];
    }
    
    getAllCards() {
        return this.cardPatterns;
    }
    
    // Method to validate if numbers match a card
    validateCardNumbers(cardId, numbers) {
        const card = this.getCard(cardId);
        if (!card) return false;
        
        // Check if all numbers match (except FREE space)
        for (let i = 0; i < 25; i++) {
            const cardNum = card.flatNumbers[i];
            const checkNum = numbers[i];
            
            if (cardNum === 'FREE' && checkNum === 'FREE') continue;
            if (cardNum !== checkNum) return false;
        }
        
        return true;
    }
    
    // Method to check winning lines
    checkWinningLines(cardId, calledNumbers) {
        const card = this.getCard(cardId);
        if (!card) return [];
        
        const winningLines = [];
        const calledSet = new Set(calledNumbers);
        
        // Check rows
        for (let row = 0; row < 5; row++) {
            let isComplete = true;
            for (let col = 0; col < 5; col++) {
                const num = card.numbers[row][col];
                if (num === 'FREE') continue;
                if (!calledSet.has(num)) {
                    isComplete = false;
                    break;
                }
            }
            if (isComplete) winningLines.push(`row${row}`);
        }
        
        // Check columns
        for (let col = 0; col < 5; col++) {
            let isComplete = true;
            for (let row = 0; row < 5; row++) {
                const num = card.numbers[row][col];
                if (num === 'FREE') continue;
                if (!calledSet.has(num)) {
                    isComplete = false;
                    break;
                }
            }
            if (isComplete) winningLines.push(`col${col}`);
        }
        
        // Check diagonal (top-left to bottom-right)
        let diag1Complete = true;
        for (let i = 0; i < 5; i++) {
            const num = card.numbers[i][i];
            if (num === 'FREE') continue;
            if (!calledSet.has(num)) {
                diag1Complete = false;
                break;
            }
        }
        if (diag1Complete) winningLines.push('diag1');
        
        // Check diagonal (top-right to bottom-left)
        let diag2Complete = true;
        for (let i = 0; i < 5; i++) {
            const num = card.numbers[i][4 - i];
            if (num === 'FREE') continue;
            if (!calledSet.has(num)) {
                diag2Complete = false;
                break;
            }
        }
        if (diag2Complete) winningLines.push('diag2');
        
        return winningLines;
    }
}

// Global instance
const bingoCards = new BingoCards();