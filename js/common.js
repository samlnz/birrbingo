[file name]: common.js
[file content begin]
// Common utility functions for the Bingo game

class GameState {
    constructor() {
        this.selectedCards = [];
        this.playerName = 'Telegram User';
        this.playerId = '0000';
        this.gameTime = 0;
        this.calledNumbers = new Set();
        this.markedNumbers = { card1: new Set(), card2: new Set() };
        this.winningLines = { card1: [], card2: [] };
        this.activePlayers = 0;
        this.isAudioEnabled = true;
        this.isAutoMark = true;
        this.gameActive = true; // Add this to track game state
    }

    saveToSession() {
        sessionStorage.setItem('bingoGameState', JSON.stringify({
            selectedCards: this.selectedCards,
            playerName: this.playerName,
            playerId: this.playerId,
            gameTime: this.gameTime,
            calledNumbers: Array.from(this.calledNumbers),
            markedNumbers: {
                card1: Array.from(this.markedNumbers.card1),
                card2: Array.from(this.markedNumbers.card2)
            },
            winningLines: this.winningLines,
            activePlayers: this.activePlayers,
            isAudioEnabled: this.isAudioEnabled,
            isAutoMark: this.isAutoMark,
            gameActive: this.gameActive // Save this too
        }));
    }

    loadFromSession() {
        const saved = sessionStorage.getItem('bingoGameState');
        if (saved) {
            const data = JSON.parse(saved);
            this.selectedCards = data.selectedCards || [];
            this.playerName = data.playerName || 'Telegram User';
            this.playerId = data.playerId || '0000';
            this.gameTime = data.gameTime || 0;
            this.calledNumbers = new Set(data.calledNumbers || []);
            this.markedNumbers = {
                card1: new Set(data.markedNumbers?.card1 || []),
                card2: new Set(data.markedNumbers?.card2 || [])
            };
            this.winningLines = data.winningLines || { card1: [], card2: [] };
            this.activePlayers = data.activePlayers || 0;
            this.isAudioEnabled = data.isAudioEnabled !== undefined ? data.isAudioEnabled : true;
            this.isAutoMark = data.isAutoMark !== undefined ? data.isAutoMark : true;
            this.gameActive = data.gameActive !== undefined ? data.gameActive : true; // Load this too
        }
    }

    clearSession() {
        sessionStorage.removeItem('bingoGameState');
    }
}

class BingoUtils {
    static BINGO_LETTERS = ['B', 'I', 'N', 'G', 'O'];
    
    static BINGO_RANGES = {
        'B': { min: 1, max: 15 },
        'I': { min: 16, max: 30 },
        'N': { min: 31, max: 45 },
        'G': { min: 46, max: 60 },
        'O': { min: 61, max: 75 }
    };

    static getLetterForNumber(number) {
        for (const [letter, range] of Object.entries(this.BINGO_RANGES)) {
            if (number >= range.min && number <= range.max) {
                return letter;
            }
        }
        return '';
    }

    static generateRandomNumber(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    static generateUniqueNumbers(count, min, max, exclude = new Set()) {
        const numbers = new Set();
        while (numbers.size < count) {
            const num = this.generateRandomNumber(min, max);
            if (!exclude.has(num)) {
                numbers.add(num);
            }
        }
        return Array.from(numbers);
    }

    static formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    static playAudio(audioElement, volume = 1) {
        if (audioElement && gameState.isAudioEnabled) {
            audioElement.volume = volume;
            audioElement.currentTime = 0;
            audioElement.play().catch(e => console.log('Audio play failed:', e));
        }
    }

    static showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
            <div class="notification-content">
                <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                <span>${message}</span>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.classList.add('show');
        }, 10);
        
        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 300);
        }, 3000);
    }

    static createLoadingOverlay(text = 'Loading...') {
        const overlay = document.createElement('div');
        overlay.className = 'loading-overlay';
        overlay.innerHTML = `
            <div class="loading-spinner"></div>
            <div class="loading-text">${text}</div>
        `;
        
        document.body.appendChild(overlay);
        
        setTimeout(() => {
            overlay.classList.add('active');
        }, 10);
        
        return {
            hide: () => {
                overlay.classList.remove('active');
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            },
            updateText: (newText) => {
                overlay.querySelector('.loading-text').textContent = newText;
            }
        };
    }

    static navigateTo(url, transition = true) {
        if (transition) {
            const transitionOverlay = document.createElement('div');
            transitionOverlay.className = 'page-transition';
            document.body.appendChild(transitionOverlay);
            
            setTimeout(() => {
                transitionOverlay.classList.add('active');
                setTimeout(() => {
                    window.location.href = url;
                }, 800);
            }, 100);
        } else {
            window.location.href = url;
        }
    }
    
    static autoRedirect(url, delay = 3000, message = "Redirecting...") {
        const overlay = document.createElement('div');
        overlay.className = 'auto-win-notification';
        overlay.innerHTML = `
            <div>${message}</div>
            <div class="redirect-countdown">Auto-redirect in ${delay/1000} seconds...</div>
        `;
        
        document.body.appendChild(overlay);
        
        setTimeout(() => {
            overlay.remove();
            this.navigateTo(url);
        }, delay);
        
        // Countdown animation
        let count = delay/1000;
        const countdownEl = overlay.querySelector('.redirect-countdown');
        const countdownInterval = setInterval(() => {
            count--;
            if (count > 0) {
                countdownEl.textContent = `Auto-redirect in ${count} seconds...`;
            }
            if (count <= 0) {
                clearInterval(countdownInterval);
            }
        }, 1000);
    }
    
    // NEW: Method to check if any winning pattern exists
    static hasWinningPattern(cardId, markedNumbers, calledNumbers) {
        const allMarked = new Set(markedNumbers);
        allMarked.add('FREE');
        
        // Check rows
        for (let row = 0; row < 5; row++) {
            let rowComplete = true;
            for (let col = 0; col < 5; col++) {
                const cell = document.querySelector(`[data-card="${cardId}"][data-row="${row}"][data-col="${col}"]`);
                if (!cell) continue;
                
                const number = cell.dataset.number;
                const isFreeSpace = row === 2 && col === 2;
                
                if (!isFreeSpace) {
                    const num = parseInt(number);
                    if (!allMarked.has(num) || !calledNumbers.has(num)) {
                        rowComplete = false;
                        break;
                    }
                }
            }
            if (rowComplete) return true;
        }
        
        // Check columns
        for (let col = 0; col < 5; col++) {
            let colComplete = true;
            for (let row = 0; row < 5; row++) {
                const cell = document.querySelector(`[data-card="${cardId}"][data-row="${row}"][data-col="${col}"]`);
                if (!cell) continue;
                
                const number = cell.dataset.number;
                const isFreeSpace = row === 2 && col === 2;
                
                if (!isFreeSpace) {
                    const num = parseInt(number);
                    if (!allMarked.has(num) || !calledNumbers.has(num)) {
                        colComplete = false;
                        break;
                    }
                }
            }
            if (colComplete) return true;
        }
        
        // Check diagonal (top-left to bottom-right)
        let diag1Complete = true;
        for (let i = 0; i < 5; i++) {
            const cell = document.querySelector(`[data-card="${cardId}"][data-row="${i}"][data-col="${i}"]`);
            if (!cell) continue;
            
            const number = cell.dataset.number;
            const isFreeSpace = i === 2;
            
            if (!isFreeSpace) {
                const num = parseInt(number);
                if (!allMarked.has(num) || !calledNumbers.has(num)) {
                    diag1Complete = false;
                    break;
                }
            }
        }
        if (diag1Complete) return true;
        
        // Check diagonal (top-right to bottom-left)
        let diag2Complete = true;
        for (let i = 0; i < 5; i++) {
            const cell = document.querySelector(`[data-card="${cardId}"][data-row="${i}"][data-col="${4 - i}"]`);
            if (!cell) continue;
            
            const number = cell.dataset.number;
            const isFreeSpace = i === 2;
            
            if (!isFreeSpace) {
                const num = parseInt(number);
                if (!allMarked.has(num) || !calledNumbers.has(num)) {
                    diag2Complete = false;
                    break;
                }
            }
        }
        if (diag2Complete) return true;
        
        return false;
    }
}

// Initialize global game state
const gameState = new GameState();

// Export for use in other files
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { GameState, BingoUtils, gameState };
}
[file content end]